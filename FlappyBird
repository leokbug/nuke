#! C:/Program Files/Nuke10.5v1/nuke-10.5.1.dll -nx
version 10.5 v1
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="0" w="1920" h="1080" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1434" stretch="1"/>
            <splitter orientation="2">
                <split size="1018"/>
                <dock id="" activePageId="DAG.1">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                </dock>
            </splitter>
            <split size="422"/>
            <splitter orientation="2">
                <split size="154"/>
                <dock id="" activePageId="mk_Panelski">
                    <page id="mk_Panelski"/>
                </dock>
                <split size="104"/>
                <dock id="" activePageId="Grabski">
                    <page id="mk_Grabski"/>
                    <page id="Grabski"/>
                </dock>
                <split size="752"/>
                <dock id="" activePageId="Properties.1" focus="true">
                    <page id="Properties.1"/>
                </dock>
            </splitter>
        </splitter>
    </window>
    <window x="-1920" y="0" w="1912" h="1100" screen="1">
        <splitter orientation="2">
            <split size="1061"/>
            <dock id="" activePageId="Viewer.1">
                <page id="Viewer.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name C:/Users/mateu/Desktop/FlappyBird_v1.nk
 mapsize {0.009624639076 0.03822937626}
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
NoOp {
 inputs 0
 name FlappyBird
 onCreate nuke.thisNode().knob('reloadScores').execute()
 tile_color 0x55949fff
 note_font "Verdana Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold"
 selected true
 xpos 1708
 ypos -3445
 addUserKnob {20 flappyBird l "Flappy Bird"}
 addUserKnob {2 highScoresPath l INVISIBLE -STARTLINE +INVISIBLE}
 addUserKnob {22 start l Start T "import os, math, random, threading\n\n#Add menu and shortcuts\nmenubar = nuke.menu(\"Nuke\");\nm = menubar.addMenu('FlappyBird')\n#Movement Keys\nm.addCommand('Jump', \"jump()\" , 'x')  \n\n\n\n#Some initial stuff\nthis = nuke.thisNode()\ncenter = \[this.xpos() + this.screenWidth()/2,this.ypos() + this.screenHeight()]\ndotScale = int(nuke.toNode('preferences').knob('dot_node_scale').value())\njumpSpeed = -8\ndeltaVel = 1\npipeStack = 15\npipeSegmentSpacing = 30\n\nscoreDisplay = int(this.knob('enableScoreDisplay').value())\nuseHighScores = int(this.knob('enableScores').value())\n\n\n#Making an arena\narenaHeight = 600\narenaWidth = 800\narena = nuke.nodes.BackdropNode(tile_color = '1435803647',xpos = center\[0] - arenaWidth/2, ypos = center\[1] + 75, bdwidth = arenaWidth, bdheight = arenaHeight, z_order = -10)\narena.setName('Arena')\n\n\n#defining eye and wing offsets to accommodate for different dot scales\nif dotScale == 1:\n    wingXOffset = 18\n    wingYUpOffset = 34\n    wingYDownOffset = 19\n    eyeXOffset = 39\n    eyeYUpOffset = 17\n    eyeYDownOffset = 33\n\nelse:\n    wingXOffset = -2\n    wingYUpOffset = 22\n    wingYDownOffset = 14\n    eyeXOffset = 31\n    eyeYUpOffset = 12\n    eyeYDownOffset = 24\n\n#Clear potentially already existing stuff from previous game\n\ntry:\n    for n in nuke.allNodes('BackdropNode'):\n        if n.name().startswith('Score_Board'):\n            nuke.delete(n)\n\n    for n in nuke.allNodes('Dot'):\n        if n.name().startswith('pixel'):\n            nuke.delete(n)\nexcept:\n    pass\n\n#Making BG buildings\n\nbgBuildings = \[nuke.nodes.BackdropNode(tile_color = '1619628543') for x in range(0,5)]\n\nfor building in bgBuildings:\n    building.setXpos(arena.xpos()+int(0.05*arenaWidth + (arenaWidth/(len(bgBuildings))*(bgBuildings.index(building)))))\n    building.setYpos(arena.ypos()+ random.randint(arenaHeight*0.65,arenaHeight*0.8))\n    building.knob('name').setValue('')\n    building.knob('bdwidth').setValue(random.randint(60,120))\n    building.knob('bdheight').setValue(arena.ypos()+arenaHeight-building.ypos())\n\n\n#Making Clouds\ncloudList = \[]\nfor i in range(0,20):\n    cloud = nuke.nodes.Axis(tile_color = '4294967295', xpos = arena.xpos()+int((random.randint(60,arenaWidth-60)/200))*200+random.randint(-60,60), ypos = arena.ypos() + random.randint(int(arenaHeight*.05),int(arenaHeight*.15)),hide_input = 'True')\n    cloud.knob('name').setValue('')\n    cloudList.append(cloud)\n\n\n#Making the bird\n\nbirdBody = nuke.nodes.Axis(tile_color = '4292215039',xpos = arena.xpos()+ int(arenaWidth/3), ypos = arena.ypos()+90, hide_input = 'True')\nbirdBody.setName('o')\n\nwing = nuke.nodes.Dot(tile_color = '3380084991',xpos = birdBody.xpos() + wingXOffset, ypos = birdBody.ypos() + 34, hide_input = 'True')\nwing.setName('Wing')\n\neye = nuke.nodes.Dot(tile_color = '255',xpos = birdBody.xpos() + eyeXOffset, ypos = birdBody.ypos() + 17, hide_input = 'True')\neye.setName('Eye')\n\nbeak = nuke.nodes.BackdropNode(tile_color = '3682271487',xpos = birdBody.xpos() + 16, ypos = birdBody.ypos() + 7, bdwidth = 43, bdheight = 23, z_order = 15)\nbeak.setName('Beak')\n\n\n#Making the pipes\n#Adding them to lists, so we can move them around later\npipeList = \[]\nfirstPipeList = \[]\nsecondPipeList = \[]\n\nbothPipeLists = \[firstPipeList,secondPipeList]\n\n#These ones are specifically for collision detection\ntopOfGap = \[]\nbottomOfGap = \[]\n\n#for each pipe, make segments from top to bottom until random integer k, then continue making the rest from bottom to top (creating a gap in the middle)\nfor j in range (0,2):\n\tk = random.randint(1,pipeStack-1)\n\tfor i in range (0,pipeStack):\n\t\tn = nuke.nodes.NoOp(tile_color= '11337983', hide_input = 'True' )\n\t\tn.knob('name').setValue('')\n\t\tn.setXpos(birdBody.xpos() - 85 + j*int(arenaWidth/2 -40))\n\t\tpipeList.append(n)\n\t\tbothPipeLists\[j].append(n)\n\n\t\tif i<k:\n\t\t\tn.setYpos(arena.ypos() + i*pipeSegmentSpacing)\n\t\tif i >=k:\n\t\t\tn.setYpos(arena.ypos() +arenaHeight - 20 - (i-k)*pipeSegmentSpacing)\n\n\t\t#Storing some extra info in the top segment of each pipe\n\t\tif i == 0:\n\t\t\tcounter = nuke.Array_Knob('counter', 'Counter')\n\t\t\tgapSlot = nuke.Array_Knob('gapSlot', 'gapSlot')\n\t\t\tn.addKnob(gapSlot)\n\t\t\tn.addKnob(counter)\n\t\t\tgapSlot.setValue(int(k))\n\t\t\tcounter.setValue(j)\n\n#Make Grass\ngrassBlades = \[nuke.nodes.Dot(tile_color = 6881535,hide_input = True) for x in range (0,int(arenaWidth/4))]\nfor grassBlade in grassBlades:\n    grassBlade.setXpos(arena.xpos()+grassBlades.index(grassBlade)*4+random.randint(-3,3))\n    grassBlade.setYpos(arena.ypos()+arenaHeight+random.randint(-6,0))\n\n\n\n#Setting Starting Conditions\nthis.knob('frameCounter').setValue(0)\nthis.knob('run').setValue(1)\nthis.knob('velocity').setValue(0)\nthis.knob('score').setValue(0)\n\n\n#Frame counter is so that we can execute certain things every certain integer number of frames (instead of on every frame)\n\ndef runFrameCounter():\n    this.knob('frameCounter').setValue((this.knob('frameCounter').value()+1)%24)\n\n\ndef jump():\n    this.knob('velocity').setValue(jumpSpeed)\n\n\ndef movePipes():\n\tif this.knob('frameCounter').value()%2 == 0:\n\t\tk = random.randint(1,pipeStack-1)\n\t\t#iterate through individual nodes, if it's the first one, store the random number value in it. Also store the score\n\t\tfor pList in bothPipeLists:\n\t\t\tpList\[0].knob('gapSlot').setValue(k)\n\t\t\tif pList\[0].xpos()<=arena.xpos():\n\t\t\t\tthis.knob('score').setValue(this.knob('score').value() + 1)\n\t\t\t\t#increase the pipe counter to reflect score\n\t\t\t\tpList\[0].knob('counter').setValue(pList\[0].knob('counter').value(+2))\n\t\t\telse:\n\t\t\t\tpass\n\n\t\t\tfor n in pList:\n\t\t\t\tif n.xpos()<=arena.xpos():\n\t\t\t\t\tn.setXpos(arena.xpos() + arenaWidth - 80)\n\n\t\t\t\t\tind = pList.index(n)\n\t\t\t\t\tif ind<=k:\n\t\t\t\t\t\tn.setYpos(arena.ypos() + ind*pipeSegmentSpacing)\n\t\t\t\t\telse: \n\t\t\t\t\t\tn.setYpos(arena.ypos() + arenaHeight - 20 - (ind-1-k)*pipeSegmentSpacing)\n\t\t\t\t\t#Update the k value to latest\n\t\t\t\t\tpList\[0].knob('gapSlot').setValue(k)\n\n\t\t\t\telse:\n\t\t\t\t\tn.setXpos(n.xpos()-3)\n\ndef moveGrass():\n\n    for n in grassBlades:\n        if n.xpos()<=arena.xpos():\n            n.setXpos(arena.xpos() + arenaWidth - dotScale*12)\n            n.setYpos(n.ypos()+random.randint(-3,3))\n        else:\n            n.setXpos(n.xpos()-2)\n\ndef moveClouds():\n    if this.knob('frameCounter').value()%6 == 0:\n        for n in cloudList:\n            if n.xpos()<=arena.xpos():\n                n.setXpos(arena.xpos() + arenaWidth - n.screenWidth()-random.randint(0,10))\n                n.setYpos(n.ypos()+random.randint(-10,10))\n            else:\n                n.setXpos(n.xpos()-1)\n\ndef currentPos(a):\n    centerX = int( a.xpos() + a.screenWidth()/2)\n    centerY = int( a.ypos() + a.screenHeight()/2)\n    return \[centerX, centerY]\n\ndef checkDistance(a,b):\n    ax = currentPos(a)\[0]\n    ay = currentPos(a)\[1]\n    bx = currentPos(b)\[0]\n    by = currentPos(b)\[1]\n    dist = int(math.sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by)))\n    return dist\n\ndef checkDistanceByXY(ax,ay,bx,by):\n    dist = int(math.sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by)))\n    return dist\n\n\ndef collisionDetection():\n\t#first check approximates the bird as a square - to quickly eliminate non-colliding NoOps\n\tcollideList = \[]\n\tfor pList in bothPipeLists:\n\t\tfor node in pList:\n\t\t\tif node.xpos()>birdBody.xpos()+60:\n\t\t\t\tpass\n\t\t\telif node.xpos()+node.screenWidth()<birdBody.xpos():\n\t\t\t\tpass\n\t\t\telif node.ypos()>birdBody.ypos()+60:\n\t\t\t\tpass\n\t\t\telif node.ypos()+node.screenHeight()<birdBody.ypos():\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tcollideList.append(node)\n\n\t#refined algorithm to run only on nodes that collide with the square - checking if any corners of a node are inside the circle\n\n\tfor node in collideList:\n\t\tif min(checkDistanceByXY(currentPos(birdBody)\[0],currentPos(birdBody)\[1],node.xpos(),node.ypos()),checkDistanceByXY(currentPos(birdBody)\[0],currentPos(birdBody)\[1],node.xpos()+node.screenWidth(),node.ypos()),checkDistanceByXY(currentPos(birdBody)\[0],currentPos(birdBody)\[1],node.xpos(),node.ypos()+node.screenHeight()),checkDistanceByXY(currentPos(birdBody)\[0],currentPos(birdBody)\[1],node.xpos()+node.screenWidth(),node.ypos()+node.screenHeight()))>30:\n\t\t\tcollideList.remove(node)\n\n\tif len(collideList)>0:\n\t\treturn True\n\telif birdBody.knob('ypos').value()>(arena.knob('ypos').value()+arena.knob('bdheight').value())-60:\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef gravity():\n    vel = this.knob('velocity').value()\n    if this.knob('frameCounter').value()%3 == 0:\n        this.knob('velocity').setValue(vel+deltaVel)\n\n    #Moving the bird (also preventing from going above the map)\n    if birdBody.ypos()<=arena.ypos():\n        birdBody.setYpos(arena.ypos()+1)\n        this.knob('velocity').setValue(1)\n    else:\n        birdBody.setYpos(int(birdBody.knob('ypos').value()+vel))\n\n    beak.setXpos(int(birdBody.knob('xpos').value()+16))\n    eye.setXpos(int(birdBody.knob('xpos').value()+eyeXOffset))\n    wing.setXpos(int(birdBody.knob('xpos').value()+wingXOffset+(random.randint(0,1)*2)-1))\n\n    if vel<=0:\n       beak.setYpos(int(birdBody.knob('ypos').value()+7))\n       eye.setYpos(int(birdBody.knob('ypos').value()+eyeYUpOffset))\n       wing.setYpos(int(birdBody.knob('ypos').value()+wingYUpOffset+(random.randint(0,1)*8)-4))\n    else:\n       beak.setYpos(int(birdBody.knob('ypos').value()+29))\n       eye.setYpos(int(birdBody.knob('ypos').value()+eyeYDownOffset))\n       wing.setYpos(int(birdBody.knob('ypos').value()+wingYDownOffset+(random.randint(0,1)*8)-4))\n\n\n\n\n\n#This whole bit deals with the scoreboard\n\nif scoreDisplay == 0:\n\tpass\nelse:\n\tscoreBoard = nuke.nodes.BackdropNode(xpos = arena.xpos(), ypos = arena.ypos() + arenaHeight, bdwidth = arenaWidth, bdheight = 12*11, tile_color = '1178417407')\n\tscoreBoard.setName('Score_Board')\n\tdotSize = 12\n\n\tpixelList = \[]\n\tfor n in range (0,105):\n\t    pixel = nuke.nodes.Dot(hide_input = 1, tile_color = '3629449471')\n\t    pixel.setXpos((int(arena.xpos()+5*dotSize)))\n\t    pixel.setYpos(int(arena.ypos()+ arenaHeight + 3*dotSize))\n\t    pixel.setName('pixel')\n\t    pixelList.append(pixel)\n\n\n\tnumberList = \[\n\t\[0,1,1,1,0,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0],\n\t\[0,0,1,0,0,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1],\n\t\[0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1],\n\t\[0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0],\n\t\[0,0,0,0,1,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,0,1],\n\t\[1,1,1,1,1,1,0,0,0,0,1,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0],\n\t\[0,1,1,1,0,1,0,0,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0],\n\t\[1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0],\n\t\[0,1,1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0],\n\t\[0,1,1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0]\n\t]\n\n\t#SCORE: letters list\n\n\tscoreList = \[\n\t\[0,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0],\n\t\[0,1,1,1,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1,1,1,0],\n\t\[0,1,1,1,0,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0],\n\t\[1,1,1,1,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,0,0,1],\n\t\[1,1,1,1,1,1,0,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,1,1,1],\n\t\[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0]\n\t]\n\n\t#Create 'Score:' text:\n\n\tfor k in range (0,len(scoreList)):\n\t    for j in range (0,35):\n\t        if scoreList\[k]\[j] == 0:\n\t            pass\n\t        else:\n\t            pixel = nuke.nodes.Dot(hide_input = True, tile_color = '3629449471')\n\t            pixel.setName('pixelDisplay')\n\t            pixel.setXpos(int(arena.xpos()+2*dotSize+(j%5*dotSize)+k*7*dotSize))\n\t            pixel.setYpos(int(arena.ypos()+ arenaHeight + 3*dotSize + ((j-(j%5))/5)*dotSize))\n### The above is where the scoreboard creation ends\n\n\ndef displayScore():\n\tif scoreDisplay == 0:\n\t\tpass\n\telse:\n\t    #only update once every 96 frames\n\t    if this.knob('frameCounter').value()%12 != 0:\n\t        pass\n\t    else:\n\t        #compare previously updated score to current score - if no change, don't update needlessly\n\t        if this.knob('score').value() == this.knob('lastScore').value():\n\t            pass\n\t        else:\n\t            #update last score to latest score\n\t            this.knob('lastScore').setValue(this.knob('score').value())\n\t            #then proceed to update the display\n\t            for pixel in pixelList:\n\t                pixel.setXpos((int(arena.xpos()+5*dotSize)))\n\t                pixel.setYpos(int(arena.ypos()+ arenaHeight + 3*dotSize))\n\n\t            score = str(int(this.knob('score').value()))\n\t            for k in range (0,len(str(score))):\n\n\t                digit = str(score)\[k]\n\n\t                for j in range(0,len(numberList\[int(digit)])):\n\t                    if int(numberList\[int(digit)]\[j]) == 0:\n\t                        pass\n\t                    else:\n\n\t                        pixelList\[int(k*35+j)].setXpos(int(arena.xpos()+40*dotSize+(j%5*dotSize)+k*7*dotSize))\n\t                        pixelList\[int(k*35+j)].setYpos(int(arena.ypos()+ arenaHeight + 3*dotSize + ((j-(j%5))/5)*dotSize))\n\n\ndef highScores():\n\tif useHighScores == 0:\n\t\tpass\n\telse:\n\n\t\t#define path to high scores file\n\t\tpath = this.knob('highScoresPath').value()\n\n\t\t#open file, read it as a dictionary\n\t\tif os.path.isfile(path):\n\t\t\tf = open(path,\"r\")\n\t\t\ttxt = f.read()\n\t\t\ttry:\n\t\t\t\tscoreDict = eval(txt)\n\t\t\texcept:\n\t\t\t\tscoreDict = \{\}\n\t\t\tf.close()\n\n\t\t\t#Define user name and score\n\t\t\tuser = os.getenv(\"USER\") or os.getenv(\"USERNAME\")\n\t\t\tscore = int(this.knob('score').value())\n\n\t\t\t#If new user, add score\n\t\t\tif user not in scoreDict.keys():\n\t\t\t    scoreDict\[user] = score\n\t\t\telse:\n\t\t\t#if user already in, compare current score to previous, and update if new is higher\t\n\t\t\t\tfor item in scoreDict.keys():\n\t\t\t\t\tif item == user:\n\t\t\t\t\t\tif score<= scoreDict.get(item):\n\t\t\t\t\t\t\tpass\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tscoreDict\[item] = score\n\n\t\t\t#Write updated dictionary to file\n\t\t\tf = open(path,'w')\n\t\t\tf.write(str(scoreDict))\n\t\t\tf.close()\n\t\t\t#refresh high scores\n\t\t\tthis.knob('reloadScores').execute()\n\ndef forceFrameRate():\n\tif int(this.knob('frameCounter').value())%2 == 0:\n\t\tprint 'Burd'\n\ndef gameOver():\n\tif collisionDetection() == False:\n\t\tpass\n\telse:\n\t\tnuke.menu('Nuke').removeItem('FlappyBird')\n\t\tfor itemList in \[cloudList, pipeList, bgBuildings, grassBlades, \[arena,birdBody,wing,eye,beak]]:\n\t\t\tfor n in itemList:\n\t\t\t\ttry:\n\t\t\t\t\tnuke.delete(n)\n\t\t\t\texcept:\n\t\t\t\t\tpass\n\t\thighScores()\n\t\tthis.knob('run').setValue(0)\n\n#Then just the final loop\ndef loop():\n    if this.knob('run').value() == 0:\n        pass\n    else:\n        runFrameCounter()\n        moveClouds()\n        moveGrass()\n        movePipes()\n        gravity()\n        displayScore()\n        forceFrameRate()\n        gameOver()\n        threading.Timer(0.02,loop).start()\n\nloop()" +STARTLINE}
 addUserKnob {6 enableScores l "Enable Global High Scores" +STARTLINE}
 addUserKnob {6 enableScoreDisplay l "Enable Score Display (if game crashes, disabling might help)" +STARTLINE}
 enableScoreDisplay true
 addUserKnob {26 ""}
 addUserKnob {22 reloadScores l INVISIBLE -STARTLINE +INVISIBLE T "import os\nthis = nuke.thisNode()\nscoreLength = 10\n\n#define path to high scores file\npath = this.knob('highScoresPath').value()\n\n#open file, read it as a dictionary\nif os.path.isfile(path):\n\tf = open(path,\"r\")\n\ttxt = f.read()\n\ttry:\n\t\tscoreDict = eval(txt)\n\texcept:\n\t\tscoreDict = \{\}\n\tf.close()\n\n\n\nbestUsers = sorted(scoreDict, key=scoreDict.get, reverse=True)\[:scoreLength] \n\nstring = ''\nfor user in bestUsers:\n\tstring = string + user + ': ' + str(scoreDict.get(user)) + '\\n'\n\nthis.knob('highScores').setValue(string)\n"}
 addUserKnob {26 highScores l "High Scores" T "Igor: 7\nAnne: 7\nSamantha: 5\nmateu: 4\nRob: 4\nTom: 3\nChris: 3\nMarcin: 1\n"}
 addUserKnob {3 score l INVISIBLE +INVISIBLE}
 score 1
 addUserKnob {20 instructions l Instructions n 1}
 addUserKnob {26 instructions_1 l "" +STARTLINE T "Press start. Press X on the keyboard to fly up.\n Avoid hitting the ground or the green pipes. Good luck!"}
 addUserKnob {20 endGroup n -1}
 addUserKnob {3 lastScore l INVISIBLE +INVISIBLE}
 lastScore 1
 addUserKnob {3 frameCounter l INVISIBLE +INVISIBLE}
 frameCounter 20
 addUserKnob {3 velocity l INVISIBLE +INVISIBLE}
 velocity 4
 addUserKnob {3 run l INVISIBLE +INVISIBLE}
 addUserKnob {26 ""}
 addUserKnob {26 credit l "by  @uselesscompthings" T "\nMateusz Krząstek"}
}
